# PQ乘积量化

## 原理
> 一般用于标的物的离线计算，将高维向量进行分组，对每个分组，分别进行聚类，用聚类中心的ID作为该分组上的编码，一方面可以基于不同维度表征该标的物所属类别信息（用聚类中心ID统一编码表示），一方面还将数据进行了降维（每个分组上的高维现在用低维ID表示）。  

## 例子

### 场景
> 有100万部电影，电影用256维向量表示，每维均为4字节float，用户用256维向量表示，找到推荐的10部电影。  

### 暴力方法
> 需要存储100万个256维浮点向量（约1GB内存），每次推荐需要计算100万次256维向量点积（约5亿次浮点运算），计算量过大。

### PQ算法

#### 离线预处理
> 1. 向量分割：将256维向量划分为8组，每组32维，也就是v = [v₁(32d), v₂(32d), ..., v₈(32d)]；  
> 2. 子空间聚类：对于全部100万电影，对每个32维子空间独立进行k-means聚类（k=256），得到256个聚类中心：  
> 3. 编码：对每部电影，对其每组子向量，使用其聚类中心进行表示编码，比如A电影原始向量为[v₁, v₂, ..., v₈]，其中V1向量的聚类中心ID为42，V2向量聚类中心ID是137...最终编码就是[42, 137, 86, 210, 55, 199, 3, 77]，因为ID最大为255，因此用1字节就能表示，最终编码后8字节就能表示一部电影；  

#### 在线推荐
> 1. 针对用户实时行为， 首先计算出用户的向量值，假如为[u₁, u₂, ..., u₈]；   
> 2. 对8个子空间，分别对其中的256个聚类中心计算距离，约可以相当于在此空间下，距离该聚类中的电影的距离；   
> 3. 对每部电影，计算8个空间下的距离和，比如上述的电影，距离=距离表1[42] + 距离表2[137] + ... + 距离表8[77]，取距离最小的10部就是推荐结果；   

### 优势
> 1. 节省存储：原始：100万×256×4字节 = 1GB，PQ编码：100万×8字节 = 8MB；  
> 2. 加速计算：原始：100万×256次乘法，PQ：8×256次预计算 + 100万×8次查表；  


[返回主页](../../README.md)
