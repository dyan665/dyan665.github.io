# 无锁队列

[返回主页](../../README.md)

## 指令重排
当程序为单线程时，对于变量的修改都是按序可见的，当读取一个变量的时候，肯定会对之前对该变量的修改可见，程序最终执行的结果，一定是和程序的代码顺序一致；但当程序为多线程的时候，由于编译器只知道当前线程中的读写依赖，并且可能会对指令进行重排乱序优化，同时由于多CPU核并行以及乱序执行，在多线程中，对于共享数据的执行顺序以及可见性是不确定的，因此需要手动对该部分共享数据做好控制。

比如在下面的代码中，存在两个线程并行，由于编译器的乱序优化，最终编译的可执行文件中，代码`loc_1`与`loc_2`执行顺序是不确定的，并非像代码中所示的`loc_1`执行在前`loc_2`执行在后，也可能是`loc_2`在前`loc_1`在后，因为两者并不存在数据依赖。因此`r1`与`r2`的值既可能是`0`也可能是`1`。

```cpp
x = 0, y = 0;

void thread_1() {
  x = 1; // loc_1
  r1 = y; // loc_2
  cout << r1 << endl;
}

void thread_2() {
  y = 1; // loc_3
  r2 = x; // loc_4
  cout << r2 << endl;
}

```

除此之外，即使执行顺序是代码中所示的顺序`loc_1`和`loc_3`在前，当执行到`loc_2`与`loc_4`时，`x`与`y`的值也并非全为`1`，因为当线程在各自不同CPU核上运行，当各自的修改存在于cache但未同步时，两线程中的修改其实是对别的CPU核是不可见的。在CPU中，存在多级缓存结构，每个CPU核在运行的时候，都会优先考虑自己的cache，当cache命中后，则不会从内存中取数据，并且不同CPU核的cache中的数据其实是不一致的。当其中某个CPU核对数据作出修改并保存在cache中，并且其修改未同步到内存中时，该修改操作其实是对其它核是不可见的，也就是说，当`thread_1`修改`x`的值后保存到cache中时，在另一个CPU核上的`thread_2`其实可能是看不见`x`已经被修改的，在`loc_4`处，`thread_2`其实可能看见的值还是`0`。

![多级缓存结构](./多级缓存结构.PNG)

## release-store原语


## 内核屏障



## 内核无锁队列




## SPSC无锁队列
