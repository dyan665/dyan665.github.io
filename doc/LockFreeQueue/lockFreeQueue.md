# 无锁队列

[返回主页](../../README.md)

## 指令重排
当程序为单线程时，对于变量的修改都是按序可见的，当读取一个变量的时候，肯定会对之前对该变量的修改可见，程序最终执行的结果，一定是和程序的代码顺序一致；但当程序为多线程的时候，由于编译器只知道当前线程中的读写依赖，并且可能会对指令进行重排乱序优化，同时由于多CPU核并行以及乱序执行，在多线程中，对于共享数据的执行顺序以及可见性是不确定的，因此需要手动对该部分共享数据做好控制。

比如在下面的代码中，存在两个线程并行，由于编译器的乱序优化，最终编译的可执行文件中，代码`loc_1`与`loc_2`执行顺序是不确定的，并非像代码中所示的`loc_1`执行在前`loc_2`执行在后，也可能是`loc_2`在前`loc_1`在后，因为两者并不存在数据依赖。因此`r1`与`r2`的值既可能是`0`也可能是`1`。

```cpp
x = 0, y = 0;

void thread_1() {
  x = 1; // loc_1
  r1 = y; // loc_2
  cout << r1 << endl;
}

void thread_2() {
  y = 1; // loc_3
  r2 = x; // loc_4
  cout << r2 << endl;
}

```

除此之外，即使执行顺序是代码中所示的顺序`loc_1`和`loc_3`在前，当执行到`loc_2`与`loc_4`时，`x`与`y`的值也并非全为`1`，因为当线程在各自不同CPU核上运行，当各自的修改存在于cache但未同步时，两线程中的修改其实是对别的CPU核是不可见的。在CPU中，存在多级缓存结构，每个CPU核在运行的时候，都会优先考虑自己的cache，当cache命中后，则不会从内存中取数据，并且不同CPU核的cache中的数据其实是不一致的。当其中某个CPU核对数据作出修改并保存在cache中，并且其修改未同步到内存中时，该修改操作其实是对其它核是不可见的，也就是说，当`thread_1`修改`x`的值后保存到cache中时，在另一个CPU核上的`thread_2`其实可能是看不见`x`已经被修改的，在`loc_4`处，`thread_2`其实可能看见的值还是`0`。

![多级缓存结构](./多级缓存结构.PNG)

## 关系术语
对于上述的执行顺序以及不同线程间的可见性，下面介绍相关的三个术语，为sequenced-before、happens-before、synchronizes-with。

### sequenced-before
sequenced-before描述的是单线程中的关系，具有可传递性，对于两个操作A和B，如果A sequenced-before B，则A的执行应当在B的前面，并且A执行后的结果B也能看到，它引入了一个局部有序性。

### happens-before
happens-before关系是sequenced-before关系的扩展，额外包括了多线程中的关系。如果A happens-before B，则A的内存状态将在B操作执行之前就可见，这就为线程间的数据访问提供了保证。同样也具有可传递性。

### synchronizes-with
synchronizes-with相比于happens-before，则扩展出传播关系，即如果一个线程修改某变量的之后的结果能被其它线程可见，并且修改该变量前的全部操作也能被其它线程可见，那么就是满足synchronizes-with关系，相比于happens-before只关心单变量，synchronizes-with扩展出对该变量前后的范围操作的可见性。

## release-store原语


## 内核屏障



## 内核无锁队列




## SPSC无锁队列






